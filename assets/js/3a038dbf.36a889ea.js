"use strict";(self.webpackChunkmy_site=self.webpackChunkmy_site||[]).push([[6732],{6270:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var t=n(4848),r=n(8453);const s={sidebar_position:26},i="java Abstraction",c={id:"java/Java-Abstraction",title:"Java-Abstraction",description:"Abstraction in Java refers to the concept of hiding the implementation details of a class and only exposing the essential features or behaviors to the outside world. It allows programmers to focus on what an object does rather than how it does it. Abstraction is achieved through abstract classes and interfaces in Java.",source:"@site/docs/java/Java-Abstraction.md",sourceDirName:"java",slug:"/java/Java-Abstraction",permalink:"/my-website-tutorial/docs/java/Java-Abstraction",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/java/Java-Abstraction.md",tags:[],version:"current",sidebarPosition:26,frontMatter:{sidebar_position:26},sidebar:"tutorialSidebar",previous:{title:"Java-Encapsulation",permalink:"/my-website-tutorial/docs/java/Java-Encapsulation"},next:{title:"Java-Interfaces",permalink:"/my-website-tutorial/docs/java/Java-Interfaces"}},o={},l=[];function d(e){const a={code:"code",h1:"h1",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.p,{children:"Abstraction in Java refers to the concept of hiding the implementation details of a class and only exposing the essential features or behaviors to the outside world. It allows programmers to focus on what an object does rather than how it does it. Abstraction is achieved through abstract classes and interfaces in Java."}),"\n",(0,t.jsx)(a.hr,{}),"\n",(0,t.jsx)(a.h1,{id:"java-abstraction",children:"java Abstraction"}),"\n",(0,t.jsxs)(a.ol,{children:["\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Abstract Classes"}),":"]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"An abstract class is a class that cannot be instantiated on its own and may contain abstract methods, concrete methods, instance variables, constructors, and other types of methods."}),"\n",(0,t.jsx)(a.li,{children:"Abstract methods are declared without implementation, leaving it to the subclasses to provide the implementation."}),"\n",(0,t.jsx)(a.li,{children:"Abstract classes serve as blueprints for concrete subclasses, providing a common interface for a group of related classes."}),"\n",(0,t.jsxs)(a.li,{children:["To declare an abstract class, you use the ",(0,t.jsx)(a.code,{children:"abstract"})," keyword in the class declaration."]}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"Example:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-java",children:'abstract class Shape {\r\n    protected double area;\r\n    \r\n    // Abstract method\r\n    abstract void calculateArea();\r\n    \r\n    // Concrete method\r\n    void displayArea() {\r\n        System.out.println("Area: " + area);\r\n    }\r\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Interfaces"}),":"]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"An interface in Java is a reference type that can contain only constants, method signatures, default methods, static methods, and nested types."}),"\n",(0,t.jsx)(a.li,{children:"Interfaces provide a contract for classes to implement, defining a set of methods that the implementing class must override."}),"\n",(0,t.jsx)(a.li,{children:"Interfaces allow for achieving multiple inheritance-like behavior in Java."}),"\n",(0,t.jsxs)(a.li,{children:["To declare an interface, you use the ",(0,t.jsx)(a.code,{children:"interface"})," keyword."]}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"Example:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-java",children:"interface Drawable {\r\n    void draw(); // Abstract method\r\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Abstraction in Practice"}),":"]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"Abstract classes and interfaces are often used to define common behavior across multiple classes in a hierarchy."}),"\n",(0,t.jsx)(a.li,{children:"Concrete subclasses extend abstract classes or implement interfaces, providing implementations for abstract methods."}),"\n",(0,t.jsx)(a.li,{children:"Abstraction promotes code reusability, flexibility, and maintainability by encapsulating common behavior and allowing for polymorphic behavior."}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"Example:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-java",children:"class Circle extends Shape {\r\n    private double radius;\r\n    \r\n    Circle(double radius) {\r\n        this.radius = radius;\r\n    }\r\n    \r\n    @Override\r\n    void calculateArea() {\r\n        area = Math.PI * radius * radius;\r\n    }\r\n}\r\n\r\nclass Rectangle extends Shape {\r\n    private double length;\r\n    private double width;\r\n    \r\n    Rectangle(double length, double width) {\r\n        this.length = length;\r\n        this.width = width;\r\n    }\r\n    \r\n    @Override\r\n    void calculateArea() {\r\n        area = length * width;\r\n    }\r\n}\r\n\r\nclass Main {\r\n    public static void main(String[] args) {\r\n        Circle circle = new Circle(5);\r\n        circle.calculateArea();\r\n        circle.displayArea();\r\n        \r\n        Rectangle rectangle = new Rectangle(4, 6);\r\n        rectangle.calculateArea();\r\n        rectangle.displayArea();\r\n    }\r\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(a.p,{children:["In this example, ",(0,t.jsx)(a.code,{children:"Shape"})," is an abstract class with an abstract method ",(0,t.jsx)(a.code,{children:"calculateArea()"}),". ",(0,t.jsx)(a.code,{children:"Circle"})," and ",(0,t.jsx)(a.code,{children:"Rectangle"})," are concrete subclasses of ",(0,t.jsx)(a.code,{children:"Shape"})," that provide implementations for the ",(0,t.jsx)(a.code,{children:"calculateArea()"})," method. The ",(0,t.jsx)(a.code,{children:"displayArea()"})," method demonstrates the use of a concrete method in the abstract class. Through abstraction, we achieve polymorphic behavior, as both ",(0,t.jsx)(a.code,{children:"Circle"})," and ",(0,t.jsx)(a.code,{children:"Rectangle"})," can be treated as ",(0,t.jsx)(a.code,{children:"Shape"})," objects."]})]})}function h(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>c});var t=n(6540);const r={},s=t.createContext(r);function i(e){const a=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function c(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);