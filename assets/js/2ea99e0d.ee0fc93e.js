"use strict";(self.webpackChunkmy_site=self.webpackChunkmy_site||[]).push([[308],{1507:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var t=a(4848),r=a(8453);const o={sidebar_position:24},i="java Polymorphism",s={id:"java/Java-Polymorphism",title:"Java-Polymorphism",description:"Polymorphism is a fundamental concept in object-oriented programming (OOP) that allows objects of different classes to be treated as objects of a common superclass. In Java, polymorphism is achieved through method overriding and method overloading.",source:"@site/docs/java/Java-Polymorphism.md",sourceDirName:"java",slug:"/java/Java-Polymorphism",permalink:"/my-website-tutorial/docs/java/Java-Polymorphism",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/java/Java-Polymorphism.md",tags:[],version:"current",sidebarPosition:24,frontMatter:{sidebar_position:24},sidebar:"tutorialSidebar",previous:{title:"Java-Inheritance",permalink:"/my-website-tutorial/docs/java/Java-Inheritance"},next:{title:"Java-Encapsulation",permalink:"/my-website-tutorial/docs/java/Java-Encapsulation"}},l={},d=[{value:"Method Overriding",id:"method-overriding",level:3},{value:"Method Overloading",id:"method-overloading",level:3}];function c(e){const n={code:"code",h1:"h1",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Polymorphism is a fundamental concept in object-oriented programming (OOP) that allows objects of different classes to be treated as objects of a common superclass. In Java, polymorphism is achieved through method overriding and method overloading."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h1,{id:"java-polymorphism",children:"java Polymorphism"}),"\n",(0,t.jsx)(n.h3,{id:"method-overriding",children:"Method Overriding"}),"\n",(0,t.jsx)(n.p,{children:"Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The method in the subclass has the same signature (name, parameters, and return type) as the method in the superclass."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'class Animal {\r\n    public void makeSound() {\r\n        System.out.println("Animal makes a sound");\r\n    }\r\n}\r\n\r\nclass Dog extends Animal {\r\n    @Override\r\n    public void makeSound() {\r\n        System.out.println("Dog barks");\r\n    }\r\n}\r\n\r\nclass Cat extends Animal {\r\n    @Override\r\n    public void makeSound() {\r\n        System.out.println("Cat meows");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Animal animal1 = new Dog();\r\n        Animal animal2 = new Cat();\r\n\r\n        animal1.makeSound();  // Output: Dog barks\r\n        animal2.makeSound();  // Output: Cat meows\r\n    }\r\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, both the ",(0,t.jsx)(n.code,{children:"Dog"})," and ",(0,t.jsx)(n.code,{children:"Cat"})," classes override the ",(0,t.jsx)(n.code,{children:"makeSound()"})," method from the ",(0,t.jsx)(n.code,{children:"Animal"})," superclass. When invoking ",(0,t.jsx)(n.code,{children:"makeSound()"})," on objects of type ",(0,t.jsx)(n.code,{children:"Animal"}),", the JVM dynamically binds the method call to the appropriate subclass implementation based on the actual object type."]}),"\n",(0,t.jsx)(n.h3,{id:"method-overloading",children:"Method Overloading"}),"\n",(0,t.jsx)(n.p,{children:"Method overloading occurs when a class has multiple methods with the same name but different parameter lists (different number or types of parameters)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"class Calculator {\r\n    public int add(int a, int b) {\r\n        return a + b;\r\n    }\r\n\r\n    public double add(double a, double b) {\r\n        return a + b;\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Calculator calculator = new Calculator();\r\n\r\n        System.out.println(calculator.add(1, 2));         // Output: 3\r\n        System.out.println(calculator.add(1.5, 2.5));     // Output: 4.0\r\n    }\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the ",(0,t.jsx)(n.code,{children:"Calculator"})," class has two ",(0,t.jsx)(n.code,{children:"add()"})," methods\u2014one that takes two ",(0,t.jsx)(n.code,{children:"int"})," parameters and another that takes two ",(0,t.jsx)(n.code,{children:"double"})," parameters. When invoking the ",(0,t.jsx)(n.code,{children:"add()"})," method, the JVM determines the appropriate method to call based on the argument types provided."]}),"\n",(0,t.jsx)(n.p,{children:"Polymorphism in Java allows for more flexible and modular code by promoting code reuse and allowing for a single interface to represent multiple implementations. It is a powerful concept that contributes to the design principles of abstraction, encapsulation, and inheritance in OOP."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>s});var t=a(6540);const r={},o=t.createContext(r);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);