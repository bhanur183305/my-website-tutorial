"use strict";(self.webpackChunkmy_site=self.webpackChunkmy_site||[]).push([[8076],{191:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=s(4848),t=s(8453);const a={sidebar_position:28},o="Python Polimorphism",i={id:"python/Python-Polymorphism",title:"Python-Polymorphism",description:"Polymorphism is a key concept in object-oriented programming (OOP) and refers to the ability of different classes to be treated as instances of a common superclass. In Python, polymorphism allows objects of different types to be used interchangeably through a shared interface. This shared interface can be achieved through method overriding and the use of abstract base classes (ABCs). There are two main types of polymorphism in Python: compile-time polymorphism and runtime polymorphism.",source:"@site/docs/python/Python-Polymorphism.md",sourceDirName:"python",slug:"/python/Python-Polymorphism",permalink:"/my-website-tutorial/docs/python/Python-Polymorphism",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/python/Python-Polymorphism.md",tags:[],version:"current",sidebarPosition:28,frontMatter:{sidebar_position:28},sidebar:"tutorialSidebar",previous:{title:"Python-Inheritance",permalink:"/my-website-tutorial/docs/python/Python-Inheritance"},next:{title:"Python-Iterators",permalink:"/my-website-tutorial/docs/python/Python-Iterators"}},l={},c=[];function d(e){const n={code:"code",h1:"h1",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Polymorphism is a key concept in object-oriented programming (OOP) and refers to the ability of different classes to be treated as instances of a common superclass. In Python, polymorphism allows objects of different types to be used interchangeably through a shared interface. This shared interface can be achieved through method overriding and the use of abstract base classes (ABCs). There are two main types of polymorphism in Python: compile-time polymorphism and runtime polymorphism."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h1,{id:"python-polimorphism",children:"Python Polimorphism"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Compile-time polymorphism:\r\nAlso known as method overloading, compile-time polymorphism occurs when multiple methods in a class have the same name but different parameters. Python, however, does not support method overloading like some other programming languages do. Still, we can mimic this behavior using default arguments and variable arguments."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example of compile-time polymorphism:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class MathOperations:\r\n    def add(self, a, b):\r\n        return a + b\r\n\r\n    def add(self, a, b, c):\r\n        return a + b + c\r\n\r\n# Creating objects and calling the methods\r\nmath_obj = MathOperations()\r\nprint(math_obj.add(2, 3))          # Raises an error - only one add method is allowed\r\nprint(math_obj.add(2, 3, 4))       # Output: 9\n"})}),"\n",(0,r.jsx)(n.p,{children:"In Python, only the latest defined method with a given name will be used, making method overloading less useful in this context. For practical polymorphism, we focus on runtime polymorphism."}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"Runtime polymorphism:\r\nAlso known as method overriding, runtime polymorphism occurs when a subclass provides a specific implementation for a method that is already defined in its superclass. This allows different objects to be treated interchangeably based on the shared method name and interface."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example of runtime polymorphism:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class Animal:\r\n    def make_sound(self):\r\n        return "Generic animal sound"\r\n\r\nclass Dog(Animal):\r\n    def make_sound(self):\r\n        return "Woof!"\r\n\r\nclass Cat(Animal):\r\n    def make_sound(self):\r\n        return "Meow!"\r\n\r\n# Function to make the animals speak\r\ndef animal_speak(animal):\r\n    print(animal.make_sound())\r\n\r\n# Creating objects and demonstrating polymorphism\r\nanimal_speak(Animal())  # Output: "Generic animal sound"\r\nanimal_speak(Dog())     # Output: "Woof!"\r\nanimal_speak(Cat())     # Output: "Meow!"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, we have an ",(0,r.jsx)(n.code,{children:"Animal"})," superclass and two subclasses, ",(0,r.jsx)(n.code,{children:"Dog"})," and ",(0,r.jsx)(n.code,{children:"Cat"}),". Each subclass overrides the ",(0,r.jsx)(n.code,{children:"make_sound()"})," method from the ",(0,r.jsx)(n.code,{children:"Animal"})," class to provide its specific sound. When we call ",(0,r.jsx)(n.code,{children:"animal_speak()"})," with different objects, polymorphism allows the correct overridden method to be called based on the object's actual type."]}),"\n",(0,r.jsx)(n.p,{children:"It's also worth mentioning another form of polymorphism in Python using abstract base classes (ABCs). ABCs allow you to define a common interface that derived classes must implement, ensuring a consistent behavior."}),"\n",(0,r.jsx)(n.p,{children:"Example using abstract base classes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from abc import ABC, abstractmethod\r\n\r\nclass Shape(ABC):\r\n    @abstractmethod\r\n    def area(self):\r\n        pass\r\n\r\nclass Square(Shape):\r\n    def __init__(self, side):\r\n        self.side = side\r\n\r\n    def area(self):\r\n        return self.side * self.side\r\n\r\nclass Circle(Shape):\r\n    def __init__(self, radius):\r\n        self.radius = radius\r\n\r\n    def area(self):\r\n        return 3.14 * self.radius * self.radius\r\n\r\n# Function to calculate area of any shape\r\ndef calculate_area(shape):\r\n    return shape.area()\r\n\r\n# Creating objects and demonstrating polymorphism with ABCs\r\nsquare_obj = Square(5)\r\ncircle_obj = Circle(3)\r\nprint(calculate_area(square_obj))  # Output: 25 (5 * 5)\r\nprint(calculate_area(circle_obj))  # Output: 28.26 (3.14 * 3 * 3)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, the ",(0,r.jsx)(n.code,{children:"Shape"})," class is an abstract base class with an abstract method ",(0,r.jsx)(n.code,{children:"area()"}),". The ",(0,r.jsx)(n.code,{children:"Square"})," and ",(0,r.jsx)(n.code,{children:"Circle"})," classes are derived from ",(0,r.jsx)(n.code,{children:"Shape"})," and implement the ",(0,r.jsx)(n.code,{children:"area()"})," method according to their specific formulas. The ",(0,r.jsx)(n.code,{children:"calculate_area()"})," function takes any object that is a subclass of ",(0,r.jsx)(n.code,{children:"Shape"}),", allowing us to calculate the area of different shapes interchangeably."]}),"\n",(0,r.jsx)(n.p,{children:"These examples demonstrate how Python polymorphism allows objects of different classes to be treated similarly based on their shared interface, promoting flexibility and code reusability in object-oriented programming."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>i});var r=s(6540);const t={},a=r.createContext(t);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);